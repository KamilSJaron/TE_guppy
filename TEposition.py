import sys
import argparse
# dependencies: biopython, numpy and matplotlib
import numpy
import matplotlib.pyplot as plt
from Bio import SeqIO
# conda install -c conda-forge biopython
# or
# pip install biopython

parser = argparse.ArgumentParser(description='Plot fraction of masked genome along the chromosome')
parser.add_argument('fasta_input', type=argparse.FileType('r'), help='fasta file to plot', default=sys.stdin)
parser.add_argument('-w', '-window_size', type = int, help='window size for plotting', default = 100000)
parser.add_argument('-sw', '-sliding_window', type = int, help='size of frameshift (default window_size, i.e. non-overlapping windows)', default = 0)
parser.add_argument('-ch', help='name of a chromosome/scaffold to plot (defalt all)', default = 'all')
parser.add_argument('-figure_name', help='name of the output plot (default autogenerated)', default = 'auto')

args = parser.parse_args()

if args.sw == 0:
	args.sw = args.w

if args.figure_name == 'auto':
	if args.ch != 'all':
		args.figure_name = 'figure_ch_' + args.ch + '_w' + str(args.w) + '_sw' + str(args.sw) + '.png'
	else:
		args.figure_name = 'figure_w' + str(args.w) + '_sw' + str(args.sw) + '.png'

# logging what the script is doing should always go to stderr
# stdout should be reserved for results (then the script will work with pipes as well)
sys.stderr.write('generating {}\n'.format(args.figure_name))

repeat = []
# this will be a vector that will mark splits between chromosomes
chromosome_breaks = []

# let's print a table of per window repetitive content to stdout
sys.stdout.write('chr\tstart\tend\tfraction_masked\n')
for record in SeqIO.parse(args.fasta_input, "fasta"):
	# this will be a vector of starts of windows
	if record.name != 'all' and record.name != args.ch:
		sys.stderr.write('Skipping {}\n'.format(record.name))
		continue

	window_starts = range(0, len(record.seq) - args.w, args.sw)
	for start in window_starts:
		seq = str(record.seq[start:(start + args.w)]).replace('N', '') # for now I will ignore Ns; this will load the sequence while removing Ns
		masked = len([nt for nt in seq if nt.islower()]) #Â this calculates fraction of masked  nts using list comprehension
		# list comprehension is usually faster than for loops appending to lists (it's a more optimised process)
		fraction_masked = masked / len(seq) # % of masked
		repeat.append(fraction_masked)
		sys.stdout.write('{}\t{}\t{}\t{:.4f}\n'.format(record.name, start, start + args.w, fraction_masked))
	chromosome_breaks.extend([0] * len(window_starts))

	if record.name == 'all':
		# let have some space between chromosomes
		repeat.extend([0, 0, 0, 0, 0])
		# and let the chromosome break vector to draw a line between them
		chromosome_breaks.extend([0, 0, 1, 0, 0])
	else:
		# if a chromosome was supposed to be plotted, there is not a point in iterating through others
		break

plt.figure(figsize=(20,10))
plt.plot(repeat, label = "Repeat",linewidth=3)
if record.name == 'all':
	plt.plot(chromosome_breaks, label = "chromosome breaks",linewidth=5)
plt.ylabel('Fraction of Repeat')
plt.xlabel('Position of Genome')
# this should be adjusted
# plt.title("Repetitive sequence position in male guppy's sex chromosome")
plt.legend()
plt.savefig(args.figure_name) #TEposition10k.png
# plt.show


